[TOC]

# 도메인 주도 개발 시작하기

<br/><br/><br/>

## 1. 도메인 모델 시작하기

<br/>

### 도메인이란?

---

- 예를 들어, 온라인 서점은 **구현해야 할 소프트웨어**의 대상으로 온라인으로 책을 판매하는 데 필요한 상품 조회, 구매, 결제, 배송 추적 등의 **기능**을 제공해야 한다.
- 이때, 온라인 서점은 **소프트웨어로 해결하고자 하는 문제 영역**, 즉 **도메인**에 해당한다.
- 한 도메인은 여러 개의 **하위 도메인**으로 나눌 수 있다.
- 모든 하위 도메인(기능)을 직접 구현할 필요는 없다.
- 일부 기능은 **자체 시스템**으로 구현하고, 나머지 기능은 **외부 업체의 시스템**을 사용해 처리할 수 있다.

<br/>

### 도메인 전문가와 개발자 간 지식 공유

---

- 개발자는 코딩에 앞서 **요구사항**을 올바르게 이해해야 한다.

- 요구사항을 올바르게 이해하는 가장 좋은 방법은 개발자가 **직접 전문가와 대화**하는 것이다.

  개발자와 전문가 사이에 전달자가 많을수록 정보가 왜곡되고 손실이 발생한다.

> 도메인 전문가라고 해서 항상 올바른 요구사항을 주는 것은 아니다.
>
> 도메인 전문가가 소프트웨어 전문가는 아니기 때문에 본인들이 실제로 원하는 것을 정확하게 표현하지 못할 때도 있다. 그래서 개발자는 요구사항을 이해할 때 왜 이런 기능을 요구하는지, 실제로 원하는게 무엇인지 정확하게 파악해야 한다.

<br/>

### 도메인 모델

---

- 





### 1.3. 도메인 모델

- 기본적으로 도메인 모델은 특정 도메인을 **개념적**으로 표현한 것이다.

- **도메인 모델을 표현하는 방법**으로는 클래스 다이어그램, 상태 다이어그램과 같은 UML 표기법도 있고, 관계를 표현하기 위해 그래프를 사용하거나 수식을 표현하기 위한 수학 공식을 활용할 수도 있다.

- 도메인 모델은 기본적으로 도메인 자체를 이해하기 위한 **개념 모델**로, 구현을 위해서는 구현 기술에 맞는 **구현 모델**이 따로 필요하다.

- 개념 모델과 구현 모델은 서로 다른 것이지만, 구현 모델이 개념 모델을 최대한 따르도록 할 수는 있다. (ex. 객체 기반 모델 -> 객체 지향 언어, 수학적인 모델 -> 함수)

> 도메인은 다수의 하위 도메인으로 구성되며, 각 하위 도메인이 다루는 영역은 서로 다르기 때문에 같은 용어라도 하위 도메인에 따라 의미가 달라질 수 있다.
> 
> 따라서 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안 된다. 각 하위 도메인마다 **별도로 모델**을 만들어야 한다!

### 1.4. 도메인 모델 패턴

- 일반적인 애플리케이션의 아키텍처 구성은 다음과 같다.
  
  - **사용자 인터페이스(UI) 또는 표현(Presentation)** : 사용자의 요청을 처리하고 사용자에게 정보를 보여준다.
  
  - **응용(Application)** : 사용자가 요청한 기능을 실행한다. 비즈니스 로직을 직접 구현하지 않고 도메인 계층을 조합해서 기능을 실행한다.
  
  - **도메인** : 시스템이 제공할 도메인 규칙을 구현한다.
  
  - **인프라스트럭처** : 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리한다.

- 여기서 말하는 도메인 모델은 아키텍처 상의 **도메인 계층을 객체 지향 기법으로 구현하는 패턴**을 말한다. (앞서 살펴본 도메인 모델과는 다른 의미)

- 도메인 계층은 **도메인의 핵심 규칙**을 구현해야 하며, 이런 도메인 규칙을 객체 지향 기법으로 구현하는 패턴이 도메인 모델 패턴이다.

> **개념 모델과 구현 모델**
> 
> 소프트웨어를 개발하는 동안 개발자와 관계자들은 해당 도메인을 더 잘 이해하게 되므로, **처음부터 완벽한 도메인 모델을 만들 수는 없다.**
> 
> 따라서 프로젝트 초기에는 개요 수준의 개념 모델로 도메인에 대한 전체 윤곽을 이해하는 데 집중하고, 구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전시켜 나가야 한다.

### 1.5. 도메인 모델 도출

- 도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다.

- 이 과정은 요구사항에서 출발한다.

- 요구사항을 분석하며 개념 모델과 구현 모델을 도출해 나가자.

> **문서화**
> 
> 문서화를 하는 주된 이유는 지식을 공유하기 위함이다.
> 
> 전체 구조를 이해해야 할 때는 상위 수준에서 정리한 문서를, 더 깊이 이해할 필요가 있는 부분은 코드를 통해 분석해 나가면 된다.
> 
> 이런 의미에서 코드 자체도 문서화의 대상이 되며, 따라서 도메인 관점에서 코드가 도메인을 잘 표현해야 한다.

### 1.6. 엔티티와 밸류

#### 1.6.1. 엔티티

- 엔티티의 가장 큰 특징은 **식별자**를 가진다는 것이다.

- 엔티티를 생성하고 속성을 바꾸고 삭제할 때까지 식별자는 유지된다.

- 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있다.

#### 1.6.2. 엔티티의 식별자 생성

- 엔티티의 식별자를 생성하는 시점은 도메인의 특징과 사용하는 기술에 따라 달라진다.

- 흔히 식별자는 다음 중 한 가지 방식으로 생성한다.
  
  - 특정 규칙에 따라 생성
  
  - UUID나 Nano ID와 같은 고유 식별자 생성기 사용
  
  - 값을 직접 입력
  
  - 일련번호 사용(시퀀스나 DB의 자동 증가 칼럼 사용)

#### 1.6.3. 밸류 타입

- 여러 개의 필드가 하나의 개념을 표현할 때, 혹은 하나의 필드라도 의미를 명확하게 표현하기 위해 사용한다.

- 밸류 타입의 또 다른 장점은 밸류 타입을 위한 기능을 추가할 수 있다는 것이다.

- 밸류 타입은 안전한 코드 작성을 위해 **불변(immutable)** 객체로 구현하는 것이 좋다.

#### 1.6.4. 엔티티 식별자와 밸류 타입

- **엔티티의 식별자**는 도메인에서 특별한 의미를 지니는 경우가 많기 때문에 **문자열**이나 **밸류 타입**을 사용할 수 있다.

#### 1.6.5. 도메인 모델에 set 메서드 넣지 않기

- **생성자**와 **기능 메서드**를 통해 데이터를 처리해야 한다.

### 1.7. 도메인 용어와 유비쿼터스 언어

- 전문가, 관계자, 개발자가 도메인과 관련된 **공통의 언어**를 만들어 사용함으로써 소통 과정에서 발생하는 용어의 모호함을 줄이고 개발자는 도메인과 코드 사이에서 불필요한 해석 과정을 줄일 수 있다.

---

## 2. 아키텍처 개요

### 2.1. 네 개의 영역

- **표현 영역**
  
  - 사용자의 요청을 받아 응용 영역에 전달하고, 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할
  
  - 스프링 MVC 프레임워크가 표현 영역을 위한 기술에 해당한다.
  
  - 웹 애플리케이션에서 표현 영역의 사용자는 웹 브라우저의 이용자나 REST API를 호출하는 외부 시스템이다.
  
  - 웹 애플리케이션의 표현 영역은 HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 전달하고, 응용 영역의 응답을 다시 HTTP 응답으로 변환하여 전송한다.

- **응용 영역**
  
  - 시스템이 사용자에게 제공해야 할 기능을 구현
  
  - 응용 영역은 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다.
  
  - 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.

- **도메인 영역**
  
  - 도메인 모델을 구현
  
  - 도메인 모델은 도메인의 핵심 로직을 구현한다.

- **인프라스트럭처 영역**
  
  - 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.
  
  - RDBMS 연동, 메시징 큐에 메시지 송수신, 몽고DB나 레디스와의 데이터 연동, SMTP를 이용한 메일 발송, HTTP 클라이언트를 이용해 REST API를 호출 등

### 2.2. 계층 구조 아키텍처

- 계층 구조는 그 특성상 상위 계층에서 하위 계층으로의 의존만 존재한다.

- 계층 구조를 엄격하게 적용한다면 상위 계층은 바로 아래의 계층에만 의존을 가져야 하지만, 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 한다.

- 예를 들어, 응용 계층은 외부 시스템과의 연동을 위해 인프라스트럭처 계층에 의존하기도 한다.

- 이 과정에서 표현, 응용, 도메인 계층은 구현 기술을 다루는 인프라스트럭처 계층에 종속된다.

- 상위 계층이 인프라스트럭처에 의존하면 해당 계층의 **테스트 어려움**과 **기능 확장의 어려움**이라는 두 가지 문제가 발생한다.

### 2.3. DIP

- 앞서 얘기한 것처럼, 고수준 모듈이 저수준 모듈을 사용하면 **구현 변경**과 **테스트**가 어렵다는 문제가 발생한다.

- **DIP**는 이 문제를 해결하기 위해 **저수준 모듈이 고수준 모듈에 의존**하도록 바꾼다.

- 추상화한 인터페이스를 이용하자.

- 고수준 모듈인 상위 계층이 마찬가지로 고수준 모듈인 **추상화 인터페이스를 의존**하게 하고, 추상화 인터페이스를 저수준 모듈이 **구현**하게 하면 저수준 모듈이 고수준 모듈에 의존하게 되며, 이를 **의존 역전 원칙**(DIP)이라 한다.

- 고수준 모듈은 더 이상 저수준 모듈에 의존하지 않고 구현을 추상화한 인터페이스에 의존한다. 실제 사용할 저수준 구현 객체는 **의존 주입**을 통해 전달받을 수 있다.

- 또한 **대역 객체**를 사용하여 테스트에 사용할 수 있다.

#### 2.3.1. DIP 주의 사항

- **DIP의 핵심**은 **고수준 모듈이 저수준 모듈에 의존하지 않도록 하는 것**

- 단순히 인터페이스와 구현 클래스를 분리하는 정도로 생각하여 저수준 모듈에서 인터페이스를 추출해서는 안된다.

- DIP를 적용할 때 하위 기능을 추상화한 인터페이스는 **고수준 모듈 관점**에서 도출해야 한다.

> DIP를 항상 적용할 필요는 없다. DIP의 이점을 얻는 수준에서 적용 범위를 먼저 검토해 보아라.

### 2.4. 도메인 영역의 주요 구성요소

- 도메인 영역은 **도메인의 핵심 모델**을 구현한다.

- 도메인 영역의 모델은 **도메인의 주요 개념**을 표현하며 **핵심 로직**을 구현한다.

- **도메인 영역의 주요 구성요소**는 다음과 같다.
  
  - **엔티티(ENTITY)** : 고유의 식별자를 가지며 자신의 라이프 사이클을 갖는다. 도메인의 고유한 개념을 표현하며, 도메인 모델의 데이터와 그에 관련된 기능들을 제공한다.
  
  - **밸류(VALUE)** : 고유의 식별자를 갖지는 않으며 주로 개념적으로 하나인 값을 표현할 때 사용된다. 엔티티의 속성이나 다른 밸류 타입의 속성으로도 사용 가능하다.
  
  - **애그리거트(AGGREGATE)** : 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다.
  
  - **리포지터리(REPOSITORY)** : 도메인 모델의 영속성을 처리한다. 엔티티 객체를 로딩하거나 저장하는 기능을 제공한다.
  
  - **도메인 서비스(DOMAIN SERVICE)** : 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 주로 여러 엔티티와 밸류를 필요로 하는 로직을 도메인 서비스에서 구현한다.

#### 2.4.1. 엔티티와 밸류

- **도메인 모델의 엔티티**와 **DB 모델의 엔티티**는 다르다.

- 가장 큰 차이점은, 도메인 모델의 엔티티는 데이터와 함께 **도메인 기능을 제공**한다는 점이다.

- 또 다른 차이점은, 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 **밸류 타입을 이용**해서 표현할 수 있다는 것이다.

#### 2.4.2. 애그리거트

- 도메인 모델이 커질수록 많은 엔티티와 밸류가 생기고, 모델은 점점 복잡해진다.

- 도메인 모델이 복잡해지면 개발자가 전체 구조가 아닌 한 개의 엔티티와 밸류에만 집중하게 되고, 큰 수준에서 모델을 이해하지 못해 큰 틀에서 모델을 관리할 수 없는 상황에 빠지게 된다.

- 도메인 모델에서 전체 구조를 이해하는 데 도움이 되는 것이 바로 **애그리거트**이다.

- 애그리거트는 **관련 객체를 하나로 묶은 군집**으로, 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있게 된다.

- 애그리거트는 군집에 속한 객체를 관리하는 **루트 엔티티**를 갖는다. 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 **애그리거트가 구현해야 할 기능을 제공**한다.

- 애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 **기능을 실행**하고 루트를 통해서 간접적으로 애그리거트 내의 다른 **엔티티나 밸류 객체에 접근**한다. (애그리거트 단위로 캡슐화)

- 애그리거트를 구현할 때는 고려할 것이 많다. (애그리거트 구현에 대한 내용은 3장에서 살펴보자)

#### 2.4.3. 리포지터리

- 도메인 객체를 지속적으로 사용하기 위해서는 **물리적인 저장소**에 도메인 객체를 보관해야 하는데, 이를 위해 필요한 도메인 모델이 리포지터리이다.

- 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면, 리포지터리는 **구현을 위한 도메인 모델**이다.

- 리포지터리는 **애그리거트 단위**로 도메인 객체를 저장하고 조회하는 기능을 정의한다.

- 도메인 모델을 사용해야 하는 코드는 리포지터리를 통해 도메인 객체를 구하여 도메인 객체의 기능을 실행해야 한다.

- 리포지터리 인터페이스는 도메인 모델 영역에 속하며, 실제 구현 클래스는 인프라스트럭처 영역에 속한다.

- 리포지터리를 구현하는 방법은 선택한 구현 기술에 따라 달라진다. (리포지터리 구현에 대한 내용은 4장에서 살펴보자)

### 2.5. 요청 처리 흐름

- 사용자가 애플리케이션에 **기능 실행을 요청**하면 그 요청을 처음 받는 영역은 **표현 영역**이다. (스프링 MVC에서 **컨트롤러**에 해당)

- 표현 영역은 사용자가 전송한 **데이터 형식**을 **검사**하고 응용 서비스에 맞게 **변환**하여 **응용 서비스에** 기능 실행을 **위임**한다.

- 응용 서비스는 **도메인 모델을 이용**해서 **기능을 구현**한다.

### 2.6. 인프라스트럭처 개요

- 인프라스트럭처는 표현 영역, 응용 영역, 도메인 영역을 지원한다.

- DIP에서 언급한 것처럼 도메인 영역과 응용 영역에서 인프라스트럭처의 기능을 직접 사용하는 것보다, 이 두 영역에 정의한 인터페이스를 인프라스트럭처 영역에 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게 만들어준다.

- 하지만 무조건 인프라스트럭처에 대한 의존을 없앨 필요는 없다. 스프링을 사용하는 경우 @Transactional을 사용하거나, JPA를 사용하는 경우 @Entity나 @Table을 사용하는 등 애너테이션을 도메인 모델 클래스에 사용하는 것이 XML 매핑 설정을 이용하는 것보다 편리하다.

- 구현의 편리함은 DIP가 주는 장점만큼 중요하기 때문에 DIP의 장점을 해치지 않는 범위에서 구현 기술에 대한 의존을 가져가는 것은 괜찮다! (오히려 인프라스트럭처에 대한 의존을 완전히 갖지 않도록 시도하는 것이 구현을 더 복잡하고 어렵게 만들 수 있다.)

### 2.7. 모듈 구성

- 아키텍처의 각 영역은 별도 패키지에 위치한다.

- 도메인이 크면 하위 도메인으로 나누어 하위 도메인별로 각 영역에 대한 패키지를 구성한다.

- 도메인 모듈은 애그리거트를 기준으로 다시 패키지를 구성한다.

- 애그리거트, 모델, 리포지터리는 같은 패키지에 위치시킨다.

- 모듈 구조를 얼마나 세분화해야 하는지에 대해 정해진 규칙은 없지만, 한 패키지에 너무 많은 타입이 몰려서 코드를 찾을 때 불편한 정도만 아니면 된다. (가능하면 한 패키지에 10~15개 미만의 타입을 유지)

---

## 3. 애그리거트

### 3.1. 애그리거트

- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 **애그리거트**다. 관련된 객체를 하나의 군으로 묶어주어 **상위 수준에서 도메인 모델 간의 관계를 파악**할 수 있게 한다.

- 애그리거트는 모델을 이해하는데 도움을 줄 뿐만 아니라, **일관성**을 관리하는 기준도 된다.

- 모델을 잘 이해할 수 있고 애그리거트 단위로 일관성을 관리하므로, 애그리거트는 복잡한 도메인을 단순한 구조로 만들어주고, 그만큼 도메인 기능을 **확장하거나 변경하는데 용이**하게 한다.

- 애그리거트는 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 **유사하거나 동일한 라이프 사이클**을 갖는다.

- 애그리거트는 독립된 객체 군으로, 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 따라서 각 애그리거트는 **자기 자신을 관리할 뿐** 다른 애그리거트를 관리하지 않는다.

- 애그리거트 간 경계를 설정할 때 기본이 되는 것은 **도메인 규칙**과 **요구사항**이다. 도메인 규칙에 따라 함께 생성되거나, 요구사항에 따라 함께 변경되는 객체들은 한 애그리거트에 속할 가능성이 높다.

- 'A가 B를 갖는다'로 해석할 수 있는 요구사항이 있다고 하더라도 반드시 A와 B가 한 애그리거트에 속한다는 의미는 아니다. (ex. 상품과 리뷰)

- 처음 도메인 모델을 만들기 시작하면 큰 애그리거트로 보이는 것들이 많지만, 도메인 규칙을 제대로 이해할수록 애그리거트의 실제 크기는 줄어든다. (실제로, 두 개 이상의 엔티티로 구성되는 애그리거트는 드물다)

### 3.2. 애그리거트 루트

- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 **애그리거트 전체를 관리할 주체**가 필요한데, 이 책임을 지는 것이 바로 애그리거트 루트 엔티티이다.

- 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 된다.

#### 3.2.1. 도메인 규칙과 일관성

- 애그리거트 루트의 핵심 역할은 **애그리거트의 일관성**이 깨지지 않도록 하는 것이다.

- 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 **도메인 기능을 구현**한다.

- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다.

- 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들기 위해 다음 두 가지를 적용해야 한다.
  
  - 단순히 필드를 변경하는 set 메서드를 public 범위로 만들지 않는다.
  
  - 밸류 타입은 불변으로 구현한다.

#### 3.2.2. 애그리거트 루트의 기능 구현

- 애그리거트 루트는 애그리거트 내부의 다른 **객체를 조합**해서 기능을 완성한다.

- 애그리거트 루트는 **기능 실행을 위임**하기도 한다.

#### 3.2.3. 트랜잭션 범위

- 트랜잭션 범위는 작을수록 좋다.

- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.

- 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면, 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현해야 한다. (아래와 같은 상황)
  
  - 팀 표준 : 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 한는 경우
  
  - 기술 제약 : 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 함
  
  - UI 구현의 편리 : 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 때

### 3.3. 리포지터리와 애그리거트

- 리포지터리는 애그리거트 단위로 존재한다.

- 애그리거트는 개념적으로 하나이므로, 리포지터리는 애그리거트 전체를 저장소에 영속화해야하며, 마찬가지로 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.

### 3.4. ID를 이용한 애그리거트 참조

- 애그리거트의 관리 주체는 애그리거트 루트이므로, 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조한다는 것이다.

- **필드를 통한 애그리거트 간의 참조**는 편리하지만 다음과 같은 문제들을 야기할 수 있다.
  
  - 편한 탐색 오용 : 한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 구현의 편리함 때문에 다른 애그리거트를 수정하고자 하는 유혹에 빠지기 쉽다. (높은 결합도)
  
  - 성능에 대한 고민 : 애그리거트를 직접 참조하면 지연 로딩과 즉시 로딩을 고민해야 한다.
  
  - 확장 어려움 : 트래픽이 증가할 수록 부하를 분산시키기 위해 하위 도메인별로 시스템을 분리하고, 이 과정에서 서로 다른 DBMS를 사용할 때도 있다.

- 이런 문제를 완화하기 위해 사용할 수 있는 것이 **ID를 이용한 애그리거트 간의 참조**이다.
  
  - ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다. (낮은 결합도, 높은 응집도)
  
  - 다른 애그리거트를 직접 참조하지 않으므로 지연 로딩과 즉시 로딩을 고민할 필요가 없고(낮은 구현 복잡도), 한 애그리거트에서 다른 애그리거트의 상태를 변경할 수 없어 안전하다.
  
  - 응용 서비스에서 필요한 애그리거트를 로딩하므로 애그리거트 수준에서 지연 로딩을 하는 것과 같은 결과를 만들고, 애그리거트별로 다른 구현 기술을 사용할 수 있다.

#### 3.4.1. ID를 이용한 참조와 조회 성능

- ID를 이용한 참조는 여러 애그리거트를 읽을 때 **조회 속도**가 문제 될 수 있다. (N+1 조회 문제)

- 이를 해결하기 위해 조회를 위한 **별도 DAO**를 만들어 DAO의 조회 메서드에서 **조인**을 이용해 한 번의 쿼리로 필요한 데이터를 로딩할 수 있다.
  
  - 처음 JPA를 사용하면 모든 연관을 지연 로딩과 즉시 로딩으로 어떻게든 처리하고 싶은 욕구에 사로잡히지만, 이것은 실용적이지 않다.

- 애그리거트마다 서로 다른 저장소를 사용하면 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다. 이 때는 조회 성능을 높이기 위해 **캐시**를 적용하거나 **조회 전용 저장소**를 따로 구성한다.

---

## 4. 리포지터리와 모델 구현

### 4.4. 애그리거트 로딩 전략

- 애그리거트 루트를 로딩하면 루트에 속한 모든 객체가 완전한 상태여야 한다.

```java
// product는 완전한 하나여야 한다.
Product product = productRepository.findById(id);
```

- 그러나 즉시 로딩(FetchType.EAGER)으로 설정하면, 조회시 성능 문제(N+1)가 발생한다.

- 애그리거트는 개념적으로 하나여야 하지만, 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 모든 객체를 로딩해야 하는 것은 아니다.

- 애그리거트가 완전해야 하는 이유는 두 가지 정도로 생각해 볼 수 있다.
  
  - 첫 번째는 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야 하기 때문이고,
  
  - 두 번째는 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하기 때문이다.

- 두 번째는 별도의 조회 전용 기능을 사용하는 것이 유리하므로, 결국 애그리거트의 완전한 로딩과 관련된 문제는 첫 번째(상태 변경)와 더 연관이 있다.

- 따라서 상태를 변경하는 시점에 필요한 구성요소를 로딩해도 문제가 되지 않으며, 실제로 상태 변경보다는 조회가 더 빈번히 일어나기 때문에 지연 로딩(FetchType.LAZY)으로 설정해도 문제 없다.

### 4.5. 애그리거트의 영속성 전파

- 애그리거트는 조회할 때뿐만 아니라 저장하고 삭제할 때도 하나로 처리되어야 한다.
  
  - 저장/삭제시 애그리거트 루트만이 아니라 애그리거트에 속한 모든 객체가 저장/삭제되어야 한다.

- @Embeddable 매핑 타입은 함께 저장/삭제되므로 cascade 속성을 추가로 설정하지 않아도 된다.

- @Entity 매핑 타입은 cascade 속성을 사용해서 저장/삭제시 함께 처리되도록 설정해야 한다.

- @OneToOne, @OneToMany 매핑 타입은 cascade 속성의 기본값이 없으므로 CascadeType.PERSIST, CascadeType.REMOVE를 설정한다.

```java
@OneToMany(cascade = {CascadeType.PERSIST, CascadeType.REMOVE},
        orphanRemoval = true)
...
```

### 4.6. 식별자 생성 기능

- 식별자는 크게 세 가지 방식 중 하나로 생성한다.
  
  - 사용자가 직접 생성
  
  - 도메인 로직으로 생성
  
  - DB를 이용한 일련번호 사용

- 식별자 생성 규칙이 있는 경우, 도메인 규칙이므로 **도메인 영역**에 식별자 생성 기능을 위치시켜야 한다.
  
  - 도메인 영역에 도메인 서비스(클래스)를 만들거나,
  
  - 리포지터리에 식별자 생성 메서드를 추가하여 구현하거나,
  
  - DB 자동 증가 칼럼 사용시 식별자 매핑에 @GeneratedValue를 사용한다.

- **응용 서비스**는 이 도메인 서비스를 이용해 식별자를 구하고 엔티티를 생성한다.

### 4.7. 도메인 구현과 DIP

- 지금까지 구현한 리포지터리는 DIP 원칙을 어기고 있다.
  
  - 엔티티는 JPA 구현 기술인 @Entity, @Table, @Id, @Column등의 애너테이션을 사용
  
  - 리포지터리 인터페이스는 스프링 데이터 JPA 구현 기술인 JpaRepository 인터페이스를 상속
  
  - 즉, 도메인이 인프라에 의존하고 있다.

- DIP를 적용하는 주된 이유는 저수준 구현의 변경이 고수준에 영향을 주지 않기 위함이다. 하지만 리포지터리와 도메인 모델의 구현 기술은 거의 바뀔 일이 없다.

- 또한 JPA 전용 애너테이션을 사용해도 도메인 모델을 단위 테스트하는 데 문제는 없다. 

---

## 5.스프링 데이터 JPA를 이용한 조회 기능

#### 

## 6. 응용 서비스와 표현 영역

#### 

### 표현 영역과 응용 영역

----

- **표현 영역** : 사용자의 요청(ex. HTTP request)을 해석하여 필요한 기능을 제공하는 응용 서비스를 실행한다.

- **응용 영역** : 실제 사용자가 원하는 기능을 제공하는 응용 서비스. 기능을 실행하는 데 필요한 입력 값을 메서드 인자로 받고 실행 결과를 리턴한다.

- **표현 영역은** 사용자로부터 **전달받은 데이터를** 응용 서비스가 요구하는 형식으로 **변환**하여 전달한다.

- **표현 영역은** 응용 서비스의 **실행 결과를** 사용자에게 **알맞은 형식으로 응답**한다.

#### 

### 응용 서비스의 역할

---

- 응용 서비스는 사용자(클라이언트)가 **요청한 기능을 실행**한다.

- 응용 서비스는 사용자의 요청을 처리하기 위해 리포지터리에서 도메인 객체를 가져와 사용하며, 주로 도메인 객체 간의 흐름을 제어하기 때문에 다음과 같이 단순한 형태를 갖는다.
  
  ```java
  public Result doSomeFunc(SomeReq req) {
      // 1.리포지터리에서 애그리거트 구하기 
      SomeAgg agg = someAggRepository.findById(req.getId());
      checkNull(agg);
  
      // 2.애그리거트의 도메인 기능 실행
      agg.doFunc(req.getValue());
  
      // 3.결과 리턴
      return createSuccessResult(agg);
  }
  ```

- 새로운 애그리거트를 생성하는 응용 서비스는 다음과 같다.
  
  ```java
  public Result doSomeCreation(CreateSomeReq req) {
      // 1.데이터 유효성 검사
      validate(req);
  
      // 2.애그리거트 생성
      SomeAgg newAgg = createSome(req);
  
      // 3.리포지터리에 애그리거트를 저장
      someAggRepository.save(newAgg);
  
      // 4.결과 리턴
      return createSuccessResult(newAgg);
  }
  ```

- 응용 서비스가 복잡하다면 도메인 로직의 일부를 구현하고 있을 가능성이 높다.

- **도메인 로직을** 도메인 영역과 응용 서비스에 **분산해서 구현**하면 코드 품질에 문제가 발생한다.
  
  - **코드의 응집성**이 떨어짐
  
  - 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아짐 (**코드 중복**)

- 응용 서비스는 **트랜잭션 처리** 또한 담당한다. 도메인의 상태 변경을 트랜잭션으로 처리한다.

- 그 외에 응용 서비스의 역할로는 **접근 제어**와 **이벤트 처리** 등이 있다.

#### 

### 응용 서비스의 구현

---

- 응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하며, 복잡한 로직을 수행하지 않기 때문에 **구현이 어렵지는 않다.**

- 응용 서비스의 크기
  
  - 한 클래스가 여러 역할을 갖는 것보다, **각 클래스마다 구분되는 역할**을 갖도록 해야한다.
  
  - 한 도메인과 관련된 기능을 하나의 응용 서비스 클래스에서 모두 구현하는 방식보다, 구분되는 기능을 별도의 서비스 클래스로 구현하는 방식을 사용하자.

- 응용 서비스의 인터페이스와 클래스
  
  - 인터페이스가 명확하게 필요하기 전까지는 응용 서비스에 대한 인터페이스 작성을 하지 않는 것이 좋다.
  
  - TDD를 즐겨 하고 표현 영역부터 개발을 시작한다면, 응용 서비스의 인터페이스부터 작성하게 된다.
  
  - 도메인 영역이나 응용 영역의 개발을 먼저 시작하면, 응용 서비스 클래스가 먼저 만들어진다.

- 응용 서비스는 표현 영역에서 **필요한 데이터만 리턴**하는 것이 좋다. (응집도 향상)

- 응용 서비스의 **파라미터**에 표현 영역과 관련된 타입을 **사용하면 안 된다.** (표현 영역에 대한 의존이 발생)
  
  - 응용 서비스만 단독으로 테스트하기가 어려워진다.
  
  - 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경해야 한다.
  
  - 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어질 수 있다.

#### 

### 표현 영역

---

- **표현 영역의 책임**은 크게 다음과 같다.
  
  - 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어
  
  - 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공
  
  - 사용자의 세션을 관리

#### 

### 값 검증

---

- 원칙적으로 모든 **값에 대한 검증**은 **응용 서비스**에서 처리한다.

- 스프링에는 값 검증을 위한 Validator 인터페이스를 제공하여 표현 영역에서 간결하게 검증을 할 수 있게 했다.

- 응용 서비스를 사용하는 표현 영역 코드가 한 곳이면 구현의 편리함을 위해 다음과 같이 역할을 나누어 검증을 수행할 수 있다.
  
  - 표현 영역 : 필수 값, 값의 형식, 범위 등
  
  - 응용 서비스 : 데이터의 존재 유무와 같은 논리적 오류

- 응용 서비스에서 필요한 값 검증을 모두 처리하면 작성할 코드가 늘어나는 불편함이 있지만, 반대로 응용 서비스의 완성도가 높아지는 이점이 있다.

#### 

### 권한 검사

---

- **사용자 U가 기능 F를 실행할 수 있는지** 확인하는 것이 권한 검사

- 이를 위해 스프링 시큐리티 같은 프레임워크를 사용할 수도 있지만, 유연한 만큼 복잡하기도 하므로 개발할 시스템에 맞는 권한 검사 기능을 구현하는 것이 유지 보수에 유리할 수 있다.

- 보통 다음 세 곳에서 권한 검사를 수행할 수 있다.
  
  - 표현 영역
  
  - 응용 서비스
  
  - 도메인

- **표현 영역**에서 할 수 있는 기본적인 검사는 **인증된 사용자인지** 검사하는 것이다. (아닐 경우 로그인 화면으로 리다이렉트)

- 서블릿 필터

#### 

### 조회 전용 기능과 응용 서비스

---

- 서비스에서 조회 전용 기능을 사용하면, 단순한 호출로 코드 작성이 끝나고 트랜잭션도 필요하지 않으므로 굳이 서비스를 만들 필요 없이 표현 영역에서 바로 조회 전용 기능을 사용해도 된다.

- 이와 같이 응용 서비스가 사용자 요청 기능을 실행하는 데 별다른 기여를 하지 못한다면 굳이 서비스를 만들지 않아도 된다.

<br/><br/><br/>

## 7. 도메인 서비스

<br/>

### 도메인 서비스

---

- **여러 애그리거트가 동시에 필요한 기능**을 구현하려면, 도메인 기능을 **별도 서비스**로 구현해야 한다.

- 도메인 서비스는 **도메인 영역에 위치한 도메인 로직을 표현**할 때 사용하며, 주로 다음 상황에서 사용한다.
  
  - 여러 애그리거트가 필요한 **계산 로직**이나, 한 애그리거트에 넣기에는 다소 복잡한 계산 로직
  
  - **외부 시스템 연동이 필요**한 도메인 로직 

<br/>

### 계산 로직과 도메인 서비스

---

- 응용 영역의 서비스가 응용 로직을 다룬다면, 도메인 서비스는 **도메인 로직**을 다룬다.

- 애그리거트나 밸류와는 다르게, 도메인 서비스는 **상태 없이 로직만을 구현**한다.
  
  할인 금액 계산 로직을 위한 **도메인 서비스**는 다음과 같이 **도메인의 의미가 드러나는 용어**를 **타입**과 **메서드 이름**으로 갖는다.
  
  ```java
  public class DiscountCalculationService {
  
      public Money calculateDiscountAmounts(
              List<OrderLine> orderLines,
              List<Coupon> coupons,
              MemberGrade grade) {
  
          Money couponDiscount = coupons.stream()
                              .map(coupon -> calculateDiscount(coupon))
                              .reduce(Money(0), (v1, v2) -> v1.add(v2));
  
          Money membershipDiscount = 
                  calculateDiscount(orderer.getMember().getGrade());
  
          return couponDiscount.add(membershipDiscount);
      }
  
      private Money calculateDiscount(Coupon coupon) {
          ...
      }
  
      private Money calculateDiscount(MemberGrade grade) {
          ...
      }
  }
  ```

- 할인 계산 서비스를 사용하는 주체는 **애그리거트**가 될 수도 있고 **응용 서비스**가 될 수도 있다.
  
  DiscountCalculationService를 다음과 같이 애그리거트의 결제 금액 계산 기능에 전달하면, 사용 주체는 애그리거트가 된다.
  
  ```java
  public class Order {
  
      public void calculateAmounts(
                      DiscountCalculationService disCalSvc,
                      MemberGrade grade) {
          Money totalAmounts = getTotalAmounts();
          Money discountAmounts = 
              disCalSvc.calculateDiscountAmounts(this.orderLines, this.coupons, grade);
          this.paymentAmounts = totalAmounts.minus(discountAmounts);
      }
  
      ...
  }
  ```

- 애그리거트 객체에 도메인 서비스를 전달하는 것은 응용 서비스 책임이다.
  
  ```java
  public class OrderService {
      private DiscountCalculationService discountCalculationService;
  
      @Transactional
      public OrderNo placeOrder(OrderRequest orderRequest) {
          OrderNo orderNo = orderRepository.nextId();
          Order order = createOrder(orderNo, orderRequest);
          orderRepository.save(order);
  
          return orderNo;
      }
  
      private Order createOrder(OrderNo orderNo, OrderRequest orderReq) {
          Member member = findMember(orderReq.getOrdererId());
          Order order = new Order(
                          orderNo, 
                          orderReq.getOrderLines(),
                          orderReq.getCoupons(),
                          createOrderer(member),
                          orderReq.getShippingInfo());
          order.calculateAmounts(this.discountCalculationService,
                                  member.getGrade());
  
          return order;
      }    
  
      ...
  }
  ```

> **도메인 서비스 객체를 애그리거트에 주입하지 않기**
> 
> 애그리거트의 메서드를 실행할 때 도메인 서비스 객체를 파라미터로 전달한다는 것은 **애그리거트가 도메인 서비스에 의존**한다는 것을 의미한다.
> 
> 이 때, 도메인 서비스를 필드로 추가하여 의존 주입으로 처리하는 것은 좋은 방법이 아니다.
> 
> 주입해야 할 도메인 서비스가 애그리거트의 데이터의 일부라고 보기에 무리가 있기 때문!

<br/>

- 애그리거트 메서드를 실행할 때 도메인 서비스를 인자로 전달하지 않고, 반대로 도메인 서비스의 기능을 실행할 때 애그리거트를 전달하기도 한다. (ex. 계좌 이체 기능)

- 계좌 이체에는 두 계좌 애그리거트가 관여하는데, 한 애그리거트는 금액을 출금하고 한 애그리거트는 금액을 입금한다.
  
  ```java
  public class TransferService {
  
      public void transfer(Account fromAcc, Account toAcc, Money amounts) {
          fromAcc.withdraw(amounts);
          toAcc.credit(amounts);
      }
  
      ...
  }
  ```

- 응용 서비스는 두 애그리거트를 구하여 해당 도메인 영역의 TransferService를 이용해 계좌 이체 도메인 기능을 실행한다.

- 도메인 서비스는 도메인 로직을 수행하지 응용 로직을 수행하진 않는다. 트랜잭션과 같은 로직은 응용 로직이므로 응용 서비스에서 처리해야 한다.

> 특정 기능이 응용 서비스인지 도메인 서비스인지 감을 잡기 어려울 때는 해당 로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태 값을 계산하는지 검사해 보면 된다.
> 
> 예를 들어, 계좌 이체 로직은 계좌 애그리거트의 상태를 변경하므로 도메인 로직이다.

<br/>

### 외부 시스템 연동과 도메인 서비스

---

- **외부 시스템이나 타 도메인**과의 **연동 기능**도 도메인 서비스가 될 수 있다.

- 예를 들어, **설문 조사 시스템**과 **사용자 역할 관리 시스템**이 분리되어 있다면, 설문 조사 시스템은 설문 조사를 생성할 때 사용자가 생성 권한을 가진 역할인지 확인하기 위해 역할 관리 시스템과 연동해야 한다.
  
  설문 조사 도메인 입장에서 사용자가 설문 조사 생성 권한을 가졌는지 확인하는 도메인 로직을 다음과 같은 도메인 서비스로 표현할 수 있다.
  
  ```java
  public interface SurveyPermissionChecker {
      boolean hasUserCreationPermission(String userId);
  }
  ```
  
  응용 서비스는 이 도메인 서비스를 이용해 생성 권한을 검사한다.
  
  ```java
  public class CreateSurveyService {
      private SurveyPermissionChecker permissionChecker;
  
      public Long createSurvey(CreateSurveyRequest req) {
          validate(req);
  
          // 도메인 서비스를 이용해 외부 시스템 연동을 표현
          if (!permissionChecker.hasUserCreationPermission(req.RequestorId())) {
              throw new NoPermissionException();
          }
  
          ...
      }
  
      ...
  }
  ```

- SurveyPermissionChecker 인터페이스를 구현한 클래스는 인프라스트럭처 영역에 위치해 연동을 포함한 권한 검사 기능을 구현한다.

> **도메인 서비스의 인터페이스와 클래스**
> 
> 도메인 서비스의 로직이 고정되어 있지 않은 경우, 도메인 서비스 자체를 인터페이스로 구현하고 이를 구현한 클래스를 둘 수도 있다.

<br/><br/><br/>

## 8. 애그리거트 트랜잭션 관리

<br/>

### 애그리거트와 트랜잭션

---

- 하나의 주문 애그리거트에 대해 운영자 스레드와 고객 스레드가 각각 상태를 변경하고 트랜잭션을 커밋하여 DB에 반영하면, 애그리거트의 일관성이 깨지게 된다.

- 이러한 문제가 발생하지 않도록 하려면, 다음 두 가지 중 하나를 해야한다.
  
  - 운영자가 상태를 변경하는 동안 고객이 애그리거트를 수정하지 못하게 막는다.
  
  - 운영자가 상태를 조회한 이후에 고객이 상태를 변경하면, 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.

- 이 두 가지는 애그리거트 자체의 트랜잭션과 관련이 있다.

- 애그리거트에 대해 사용할 수 있는 대표적인 **트랜잭션 처리 방식**에는 **선점(Pessimistic) 잠금**과 **비선점(Optimistic) 잠금** 방식이 있다.

<br/>

### 선점 잠금

---

- 선점 잠금(Pessimistic Lock)은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식이다.

- 선점 잠금은 보통 DBMS가 제공하는 행단위 잠금을 사용해서 구현한다.

- JPA의 Entity Manager는 LockModeType을 인자로 받는 find 메서드를 제공한다.
  
  ```java
  Order order = entityManager.find(
      Order.class,
      orderNo,
      LockModeType.PESSIMISTIC_WRITE
  );
  ```

- JPA 프로바이더와 DBMS에 따라 잠금 모드를 구현하는 방식은 조금씩 다르다. (하이버네이트의 경우 'for update' 쿼리를 이용해 선점 잠금을 구현한다.)

- 스프링 데이터 JPA는 @Lock 애너테이션을 사용해 잠금 모드를 지정한다
  
  ```java
  public interface MemberRepository extends Repository<Member, MemberId> {
  
      @Lock(LockModeType.PESSIMISTIC_WRITE)
      @Query("select m from Member m where m.id = :id")
      Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
  }
  ```

<br/>

### 선점 잠금과 교착 상태

---

- 선점 잠금 기능을 사용할 때는 잠금 순서에 따른 **교착 상태(deadlock)** 가 발생하지 않도록 주의해야 한다.

- 예를 들어, 다음과 같은 순서로 두 스레드가 잠금 시도를 한다고 해보자.
  
  1. 스레드1: A 애그리거트에 대한 선점 잠금 구함
  
  2. 스레드2: B 애그리거트에 대한 선점 잠금 구함
  
  3. 스레드1: B 애그리거트에 대한 선점 잠금 시도
  
  4. 스레드2: A 애그리거트에 대한 선점 잠금 시도

- 이 순서에 따르면 스레드1은 영원히 B 애그리거트에 대한 선점 잠금을 구할 수 없고, 마찬가지로 스레드2도 A 애그리거트에 대한 선점 잠금을 구할 수 없어 둘 다 다음 단계를 진행할 수 없다.

- 사용자 수가 많을 수록 교착 상태에 빠지기 쉽고, 더 많은 스레드가 교착 상태에 빠질수록 시스템은 아무것도 할 수 없게 된다.

- 이를 해결하기 위해서 잠금을 구할 때 **최대 대기 시간**을 지정해야 한다.

- JPA에서는 선점 잠금을 시도할 때 다음과 같이 힌트를 사용해 최대 대기 시간을 지정한다.
  
  ```java
  Map<String, Object> hints = new HashMap<>();
  hints.put("javax.persistence.lock.timeout", 2000);
  
  Order order = entityManager.find(
      Order.class,
      orderNo,
      LockModeType.PESSIMISTIC_WRITE,
      hints
  );
  ```
  
  지정한 최대 대기 시간 이내에 잠금을 구하지 못하면 익셉션을 발생시킨다.
  
  이 힌트를 사용할 때 주의할 점은 DBMS에 따라 힌트가 적용되지 않을 수 있다는 것이다. 사용중인 DBMS가 관련 기능을 지원하는지 확인하라.

- 스프링 데이터 JPA는 @QueryHints 애너테이션을 사용해 쿼리 힌트를 지정할 수 있다.
  
  ```java
  public interface MemberRepository extends Repository<Member, MemberId> {
  
      @Lock(LockModeType.PESSIMISTIC_WRITE)
      @QueryHints({
          @QueryHint(name = "javax.persistence.lock.timeout", value = "2000")
      })
      @Query("select m from Member m where m.id = :id")
      Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
  }
  ```

<br/>

### 비선점 잠금

---

- **선점 잠금으로 해결할 수 없는 문제를 해결하기 위해** 비선점 잠금을 사용한다.

- 비선점 잠금은 동시 접근을 막는 대신 **변경한 데이터를 DBMS에 반영하는 시점에 변경 가능 여부를 확인**하는 방식이다.

- 비선점 잠금을 구현하려면 애그리거트에 **버전으로 사용할 숫자 타입 프로퍼티**를 추가해야 한다.
  
  애그리거트를 수정할 때마다 버전 값이 1씩 증가하며, 다음과 같은 쿼리를 사용한다.
  
  ```sql
  UPDATE aggtable SET version = version + 1, colx = ?, coly = ?
  WHERE aggid = ? and version = 현재버전;
  ```

- 이 쿼리는 테이블의 버전 값과 애그리거트의 버전 값을 비교해 동일한 경우만 데이터를 수정하고, 수정에 성공하면 버전 값을 1 증가시킨다.

- JPA는 버전을 이용한 비선점 잠금 기능을 지원한다.
  
  다음과 같이 버전으로 사용할 필드에 @Version 애너테이션을 붙이고 매핑되는 테이블에 버전을 저장할 칼럼을 추가하면 된다.
  
  ```java
  @Entity
  @Table(name = "purchase_order")
  @Access(AccessType.FIELD)
  public class Order {
      @EmbeddedId
      private OrderNo number;
  
      @Version
      private long version;
  
      ...
  }
  ```

- 응용 서비스는 데이터 변경 트랜잭션 종료 시점에 수정된 행의 개수가 0이면 트랜잭션 충돌이 발생한 것으로 간주하여 OptimisticLockingFailureException을 발생시킨다.

- 표현 영역에서 이 예외가 발생했는지 확인하여 예외 처리 코드를 작성하면 된다.

- 비선점 잠금 방식을 여러 트랜잭션으로 확장하려면, 애그리거트 정보를 뷰로 넘길 때 버전 정보도 함께 전달해야 한다.
  
  HTML 폼을 생성하는 경우 hidden 타입의 <input> 태그를 생성해서 전달한다.
  
  ```html
  <form th:action="@{/startShipping}" method="post">
    <input type="hidden" name="version" th:value="${orderDto.version}">
  ...
  ```

- 응용 서비스에 전달할 요청 데이터는 사용자가 전송한 버전 값을 포함한다.
  
  ```java
  public class StartShippingRequest {
  
      private String orderNumber;
      private long version;
  
      ...
  }
  ```

- 응용 서비스는 전달받은 버전 값을 이용해서 애그리거트 버전과 일치하는지 확인하고, 일치하면 기능을 수행한다.
  
  ```java
  public class StartShippingService {
  
      @PreAuthorize("hasRole('ADMIN')")
      @Transactional
      public void startShipping(StartShippingRequest req) {
          Order ordr = orderRepository.findById(new OrderNo(req.getOrderNumber()));
          checkOrder(order);
          if(!order.matchVersion(req.getVersion()) {
              throw new VersionConflictException();
          }
          order.startShipping();
      }
  }
  ```

- 표현 계층은 버전 충돌 익셉션이 발생하면 버전 충돌을 사용자에게 알려 사용자가 알맞은 후속 처리를 할 수 있도록 한다.
  
  ```java
  @Controller
  public class OrderAdminController {
      private StartShippingService startShippingService;
  
      @PostMapping("/startShipping")
      public String startShipping(StartShippingRequest startReq) {
          try {
              startShippingService.startShipping(startReq);
              return "shippingStarted;"
          } catch (OptimisticLockingFailureException
                  | VersionConflictException ex) {
              //트랜잭션 충돌
              return "startShippingTxConflict";
          }
      }
  }
  ```
  
  이 코드는 비선점 잠금과 관련해서 발생하는 두 개의 익셉션을 처리하고 있다.
  
  하나는 스프링 프레임워크가 발생시키는 OptimisticLockingFailureException이고,
  
  다른 하나는 응용 서비스가 코드에서 발생시키는 VersionConflictException이다.
  
  VersionConflictException은 이미 누군가가 애그리거트를 수정했다는 것을 의미하고,
  
  OptimisticLockingFailureException은 누군가가 거의 동시에 애그리거트를 수정했다는 것을 의미한다.

<br/>

### 강제 버전 증가

---

- 애그리거트 루트 외에 다른 엔티티의 값이 변경되는 경우, JPA는 루트 엔티티의 버전 값을 증가시키지 않는다.

- 그러나 JPA의 이런 특징은 애그리거트 관점에서 문제가 된다.

- 그래서 JPA는 Entity Manager의 find 메서드로 엔티티를 구할 때 강제로 버전 값을 증가시키는 **잠금 모드**를 지원한다.
  
  ```java
  @Repository
  public calss JpaOrderRepository implements OrderRepository {
      @PersistenceContext
      private EntityManager em;
  
      @Override
      public order findByIdOptimisticLockMode(OrderNo id) {
          return em.find(
              Order.class,
              id,
              LockModeType.OPTIMISTIC_FORCE_INCREMENT
          );
      }
  }
  ```
  
  LockModeType.OPTIMISTIC_FORCE_INCREMENT를 사용하면 해당 엔티티의 변경 여부와 상관없이 트랜잭션 종료 시에 버전 값을 증가시킨다.

- 스프링 데이터 JPA에서는 앞서 살펴본 @Lock 애너테이션을 이용해서 지정하면 된다.

<br/>

### 오프라인 선점 잠금

---

- 하나의 화면 자체를 선점하는 방식은, 한 트랜잭션 범위에서만 적용되는 선점 잠금 방식이나 나중에 버전 충돌을 확인하는 비선점 잠금 방식으로 구현할 수 없다.

- 이때 필요한 것이 **오프라인 선점 잠금 방식(Offline Pessimistic Lock)** 이다.

- 오프라인 선점 잠금은 **여러 트랜잭션에 걸쳐** 동시 변경을 막는다.

- 첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제한다.

- 수정 기능을 생각해 보면, 첫 번째 트랜잭션은 폼을 보여주고(조회), 두 번째 트랜잭션은 데이터를 수정한다.

- 사용자가 마지막 트랜잭션 전에 프로그램을 종료하면 영원히 잠금이 해제되지 않으므로, 오프라인 선점 잠금 방식은 유효 시간을 가져야 한다.

- 사용자가 중간 과정을 진행하는 중에 잠금이 해제되지 않게 하려면, 일정 주기로 유효 시간을 증가시키는 방식이 필요하다.

<br/>

### 오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스

---

- 오프라인 선점 잠금은 크게 네 가지 기능이 필요하다.
  
  1. **잠금 선점 시도**
  
  2. **잠금 확인**
  
  3. **잠금 해제**
  
  4. **잠금 유효시간 연장**

- 이 기능들을 위한 **LockManager 인터페이스**는 다음과 같다.
  
  ```java
  public interface LockManager {
  
      // input : 잠그려는 대상의 타입과 식별자
      LockId tryLock(String type, String id) throws LockException;
  
      void checkLock(LockId lockId) throws LockException;
  
      void releaseLock(LockId lockId) throws LockException;
  
      void extendLockExpiration(LockId lockId, long inc throws LockException;)
  }
  ```

- **LockId 클래스**는 다음과 같다. 이 LockId는 다음에 잠금을 해제할 때 사용해야 하므로, 어딘가에 보관해야 한다.
  
  ```java
  public class LockId {
      private String value;
  
      public LockId(String value) {
          this.value = value;
      }
  
      public String getValue() {
          return value;
      }
  }
  ```

- 다음은 **컨트롤러**가 오프라인 선점 잠금 기능을 이용해 데이터 수정 폼에 **동시에 접근하는 것을 제어**하는 예제 코드이다.
  
  ```java
  // 서비스 - 잠금 ID를 리턴
  public DataAndLockId getDataWithLock(Long id) {
    // 1.오프라인 선점 잠금 시도
    LockId lockId = lockManager.tryLock("data", id);
    
    // 2.기능 실행
    Data data = someDao.select(id);
    
    return new DataAndLockId(data, lockId);
  }
  
  // 컨트롤러 - 서비스가 리턴한 잠금 ID를 모델로 뷰에 전달
  @GetMapping("/some/edit/{id}")
  public String editForm(@PathVariable("id") Long id, ModelMap model) {
    DataAndLockId dl = dataService.getDataWithLock(id);
    model.addAttribute("data", dl.getData());
    
    // 3.잠금 해제에 사용할 LockId를 모델에 추가
    model.addAttribute("lockId", dl.getLockId());
    
    return "editForm";
  }
  ```

- 잠금을 선점하는 데 실패하면 LockException이 발생한다. 예외 처리를 통해 나중에 다시 시도하라는 안내 화면을 보여주면 된다.

  ```html
  <form th:action="@{/some/edit/{id}(id=${data.id})}" method="post">
    ...
    <input type="hidden" name="lid" th:value="${lockId.value}">
    ...
  </form>
  ```

- 잠금을 해제하는 코드는 다음과 같이 전달받은 LockId를 이용한다.

  ``` java
  // 서비스 - 잠금을 해제한다
  public void edit(EditRequest editReq, LockId lockId) {
    // 1.잠금 선점 확인
    lockManager.checkLock(lockId);
    
    // 2.기능 실행
    // ...
    
    // 3.잠금 해제
    lockManager.releaseLock(lockId);
  }
  
  // 컨트롤러 - 서비스를 호출할 때 잠금 ID를 함께 전달
  @PostMapping("/some/edit/{id}")
  public String edit(
  	  	@PathVariable("id") Long id,
  	  	@ModelAttribute("editReq") EditRequest editReq,
  	  	@RequestParam("lid") String lockIdValue) {
    editReq.setId(id);
    someEditService.edit(editReq, new LockId(lockIdValue));
    model.addAttribute("data", data);
    return "editSuccess";
  }
  ```

<br/>

### DB를 이용한 LockManager 구현

---

- 추후 작업 예정

<br/><br/><br/>

## 9. 도메인 모델과 바운디드 컨텍스트

<br/>

### 도메인 모델과 경계

---

- 처음 도메인 모델을 만들 때 빠지기 쉬운 함정은, 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것이다.
- 그러나 한 도메인은 다시 여러 하위 도메인으로 구분되기 때문에, 이러한 시도는 모든 하위 도메인에 맞지 않는 모델로 이어진다.
- 모델은 특정한 컨텍스트 하에서 완전한 의미를 갖는데. 이렇게 구분되는 경계를 갖는 컨텍스트를 **바운디드 컨텍스트(Bounded Context)**라고 부른다.

<br/>

### 바운디드 컨텍스트

---

- 바운디드 컨텍스트는 **모델의 경계를 결정**하며, **한 개의 바운디드 컨텍스트**는 **논리적으로 한 개의 모델**을 갖는다.

- 또한 바운디드 컨텍스트는 실제로 사용자에게 기능을 제공하는 **물리적 시스템**으로, 도메인 모델은 이 **바운디드 컨텍스트 안에서 도메인을 구현**한다.

- 기업의 팀 조직 구조에 따라 바운디드 컨텍스트가 결정되기도 한다. 

- 또한 **여러 하위 도메인**을 **하나의 바운디드 컨텍스트에서 구현**하기도 한다.

  이 때 주의할 점은, 하위 도메인의 모델이 섞이지 않도록 하는 것이다. 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 하며, 이렇게 함으로써 하위 도메인을 위한 모델이 서로 뒤섞이지 않고 하위 도메인마다 바운디드 컨텍스트를 갖는 효과를 낼 수 있다.

- 바운디드 컨텍스트는 도메인 모델을 구분하는 경계가 되기 때문에, 구현하는 하위 도메인에 알맞은 모델을 포함한다.

<br/>

### 바운디드 컨텍스트 구현

---

- 바운디드 컨텍스트는 도메인 모델 뿐만 아니라, **표현 영역, 응용 서비스, 인프라스트럭처 영역, DBMS**를 모두 포함한다.

- 모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.

  복잡한 도메인 로직을 갖지 않는 경우, CRUD 방식으로 구현해도 기능을 유지 보수하는 데 큰 문제가 없다. (표현 영역 - 서비스 - DAO - DBMS 구조)

- 한 바운디드 컨텍스트에서 두 방식을 혼합해서 사용할 수도 있다. 대표적인 예가 **CQRS 패턴**이다.

- 각 바운디드 컨텍스트는 서로 다른 구현 기술을 사용할 수도 있다.

- 바운디드 컨텍스트가 반드시 사용자에게 보여지는 UI를 가지고 있어야 하는 것은 아니다.

<br/>

### 바운디드 컨텍스트 간 통합

---

- 두 팀이 관련된 바운디드 컨텍스트를 개발하면, 자연스럽게 두 바운디드 컨텍스트 간 통합이 발생한다.

- 예를 들어 카탈로그 하위 도메인에 개인화 추천 기능을 도입하기로 했다고 하면, 카탈로그 하위 도메인에는 기존 카탈로그를 위한 바운디드 컨텍스트와 추천 기능을 위한 바운디드 컨텍스트가 생긴다.

  카탈로그 시스템은 추천 시스템으로부터 추천 데이터를 받아오지만, 카탈로그 시스템에서는 추천의 도메인 모델을 사용하기보다는 카탈로그 도메인 모델을 사용해서 추천 상품을 표현해야 한다.

  즉, 다음과 같이 카탈로그 모델을 기반으로 하는 도메인 서비스를 이용해 상품 추천 기능을 표현해야 한다.

  ``` java
  // 상품 추천 기능을 표현하는 도메인 서비스
  public interface ProductRecommendationService {
    List<Product> getRecommendationsOf(ProductId id);
  }
  ```

- 도메인 서비스를 구현한 클래스는 인프라스트럭처 영역에 위치한다.

  이 클래스는 **외부 시스템과의 연동**을 처리하고, **외부 시스템의 모델과 현재 도메인 모델 간의 변환**을 책임진다.

- 외부 시스템은 REST API로 데이터를 제공하며, 이 데이터는 현재 시스템의 도메인 모델과 일치하지 않는다.

  다음은 구현 클래스를 가상으로 만들어 본 것이다.

  ``` java
  public class RecSystemClient implements ProductRecommendationService {
    private ProductRepository productRepository;
    
    @Override
    public List<Product> getRecommendationsOf(ProductId id) {
      List<RecommendationItem> items = getRecItems(id.getValue());
      return toProducts(items);
    }
    
    private List<RecommendationItem> getRecItems(String itemId) {
      // externalRecClient는 외부 추천 시스템을 위한 클라이언트
      return externalRecClient.getRecs(itemId);
    }
    
    private List<Product> toProducts(List<RecommendationItem> items) {
      return items.stream()
        			.map(item -> toProductId(item.getItemId()))
        			.map(prodId -> productRepository.findById(prodId))
        			.collect(toList());
    }
    
    private ProductId toProductId(String itemId) {
      return new ProductId(itemId);
    }
    
    ...
  }
  ```

- 두 모델 간의 변환 과정이 복잡하다면 **변환 처리를 위한 별도의 클래스**를 만들어 처리해도 된다.

- **REST API**를 호출하는 것은 두 바운디드 컨텍스트를 **직접 통합**하는 방법이다. **간접적으로 통합**하는 방법도 있는데, 대표적인 방식이 **메시지 큐**를 사용하는 것이다. 사용자가 조회한 상품 이력이나 구매 이력 등을 메시지 형식으로 큐에 추가하여 추천 시스템에 전달할 수 있다.

  이 때, 두 바운디드 컨텍스트 간에 **주고받을 메시지의 데이터 형식**은 서로 협의하여 맞춰야 한다.

<br/>

### 바운디드 컨텍스트 간 관계

---

- 바운디드 컨텍스트는 어떤 식으로든 연결되기 때문에 **두 바운디드 컨텍스트**는 **다양한 방식으로 관계**를 맺는다.

- 두 바운디드 컨텍스트 간 관계 중 가장 흔한 관계는 한쪽에서 **API를 제공하고** 다른 한쪽에서 그 **API를 호출하는** 관계이다. (**REST API**가 대표적)

  이 관계에서 API를 사용하는 바운디드 컨텍스트는 API를 제공하는 바운디드 컨텍스트에 **의존**하게 된다.

  예를 들어, 카탈로그 바운디드 컨텍스트는 추천 바운디드 컨텍스트가 제공하는 REST API를 호출하므로 추천 바운디드 컨텍스트에 의존한다.

- 상류 컴포넌트는 보통 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의하고 이를 공개한다. 상류 팀의 고객인 하류 팀이 다수 존재하면, 상류 팀은 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들고 이를 서비스 형태로 공개해서 서비스의 일관성을 유지할 수 있다. 이런 서비스를 **공개 호스트 서비스(OPEN HOST SERVICE)**라 한다.

  공개 호스트 서비스의 대표적인 예는 **검색**이다. 검색 시스템은 상류 컴포넌트가 되고, 검색 결과로 보여지는 블로그, 카페, 게시판 등은 하류 컴포넌트가 된다.

- 상류 컴포넌트의 서비스는 상류 바운디드 컨텍스트의 도메인 모델을 따른다. 따라서 하류 컴포넌트는 상류 서비스의 모델이 자신의 도메인 모델에 영향을 주지 않도록 보호해 주는 **완충 지대**를 만들어야 하는데, 앞서 도메인 서비스 인터페이스를 구현한 클래스가 이에 해당한다.

  이와 같이 내 모델이 깨지는 것을 막아주는 역할을 하는 장치를 **안티코럽션 계층(Anticorruption Layer)**이라 한다.

- 두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있는데, 이를 **공유 커널(SHARED KERNEL)**이라 부른다.

  공유 커널의 장점은 중복을 줄여준다는 것이고, 단점은 두 팀이 한 모델을 공유하므로 밀접한 관계를 유지해야 한다는 것이다.

  두 팀이 밀접한 관계를 형성할 수 없다면 장점보다 단점이 커지므로 사용하지 않는 것이 좋다.

- 마지막으로 살펴볼 관계는 **독립 방식(SEPARATE WAY)**이다. 서로 통합하지 않고 수동으로 데이터를 입력하는 방식이다.

  나쁜 방식은 아니지만 규모가 커질수록 한계가 있기 때문에 별도의 통합 시스템을 만들어야 한다.

<br/>

### 컨텍스트 맵

---

- 개별 바운디드 컨텍스트에 매몰되면 전체를 보지 못할 때가 있다. **전체 비즈니스를 조망할 수 있는 지도**가 필요한데, 그것이 바로 **컨텍스트 맵**이다.

  컨텍스트 맵은 **바운디드 컨텍스트 간의 관계**를 표시한 것이다.

- 컨텍스트 맵은 시스템의 전체 구조를 보여주어 바운디드 컨텍스트를 설정하고 조율하는 데 도움을 준다.

> 컨텍스트 맵은 전체 시스템의 이해 수준을 보여주므로, 시스템을 더 잘 이해하거나 컨텍스트 간 관계가 바뀌면 컨텍스트 맵도 함께 바뀐다.

<br/><br/><br/>

## 10. 이벤트

<br/>

### 시스템 간 강결합 문제

---

- 쇼핑몰에서 상품을 반품하거나 취소할 때, **주문 도메인**은 **주문 취소**를, **결제 도메인**은 **환불 처리**를 각각 해야한다.

- 먼저 **주문 도메인 엔티티**에서 **환불 기능을 실행**할 수 있다. 다음 코드와 같이 **환불 기능을 제공하는 도메인 서비스**를 파라미터로 전달받아 **취소 도메인 기능에서** 도메인 서비스를 실행한다. 

  ``` java
  public class Order {
    // ...
    
    // 외부 서비스를 실행하기 위해 도메인 서비스를 파라미터로 전달받음
    public void cancel(RefundService refundService) {
      // 주문 취소 로직
      verifyNotYetShipped();
      this.state = OrderState.CANCELED;
      
      // 환불 로직
      this.refundStatus = State.REFUND_STARTED;
      try {
        refundService.refund(getPaymentId());
        this.refundStatus = State.REFUND_COMPLETED;
      } catch (Exception ex) {
        // ...
      }
      
    }
    
    // ...
  }
  ```

- 응용 서비스에서 환불 기능을 실행할 수도 있다.

  ``` java
  public class CancelOrderService {
    private RefundService refundService;
    
    @Transactional
    public void cancel(OrderNo orderNo) {
      Order order = findOrder(orderNo);
      order.cancel();
      
      order.refundStarted();
      try {
        refundService.refund(order.getPaymentId());
        order.refundCompleted();
      } catch (Exception ex) {
        // ...
      }
    }
    
    // ...
  }
  ```

  보통 결제 시스템은 외부에 존재하므로 RefundService는 외부 결제 시스템이 제공하는 환불 서비스를 호출한다.

  이때 두 가지 문제가 발생할 수 있는데, 첫 번째는 외부 서비스가 정상이 아닐 경우 **트랜잭션 처리**를 어떻게 해야 할지 애매하다는 것이고, 두 번째는 외부 시스템의 응답 시간에 따라 대기 시간이 길어지므로 **외부 서비스 성능에 직접적인 영향**을 받게 된다는 것이다.

- 도메인 객체에 서비스를 전달하는 경우도 설계상 문제가 나타날 수 있다. 주문 로직과 결제 로직이 섞인다는 것인데, 이 경우 환불 기능이 바뀌면 Order도 영향을 받게 된다.

- 이러한 문제들은 바운디드 컨텍스트 간의 **강결합(high coupling)** 때문이다.

  이러한 강결합을 없애기 위해 **이벤트**를 사용할 수 있다. 특히 **비동기 이벤트**를 사용하면 두 시스템 간의 결합을 크게 낮출 수 있다.

<br/>

### 이벤트 개요

---

- 도메인 모델에 이벤트를 도입하려면 다음 **네 개의 구성요소**를 **구현**해야 한다.
  - **이벤트**
  - **이벤트 생성 주체** : 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체로, 이벤트를 생성하여 이벤트 디스패처에 전달한다.
  - **이벤트 디스패처 (퍼블리셔)** : 이벤트를 전달 받아 해당 이벤트를 처리할 수 있는 핸들러에 전달한다. 디스패처 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로 실행한다.
  - **이벤트 핸들러 (구독자)** : 디스패처로부터 전달받은 이벤트에 담긴 데이터를 이용해 원하는 기능을 실행한다.

<br/>

### 이벤트의 구성

---

- 이벤트는 **발생한 이벤트에 대한 정보**를 담으며, 이 정보는 다음을 포함한다.
  - **이벤트 종류** : 클래스 이름으로 이벤트 종류를 표현
  - **이벤트 발생 시간**
  - **추가 데이터** : 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

- 배송지를 변경할 때 발생하는 이벤트 클래스는 다음과 같이 작성할 수 있다.

  ``` java
  // 이벤트는 과거에 벌어진 것을 표현하므로, 이벤트 이름에는 과거 시제를 사용한다.
  public class ShippingInfoChangedEvent {
    
    private String orderNumber;
    private long timestamp;
    private ShippingInfo newShippingInfo;
  }
  ```

- 이 이벤트를 발생하는 주체는 Order 애그리거트이며, Order 애그리거트의 배송지 변경 기능을 구현한 메서드는 다음 코드처럼 배송지 정보를 변경한 뒤에 이 이벤트를 발생시킨다.

  ``` java
  public class Order {
    
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
      verifyNotYetShipped();
      setShippingInfo(newShippingInfo);
      Events.raise(new ShippingInfoChangedEvent(number, newShippingInfo));
    }
  }
  ```

  Events.raise()는 디스패처를 통해 이벤트를 전파하는 기능을 제공하는데, 이 기능의 구현은 뒤에서 살펴보자.

- 이 이벤트를 처리하는 핸들러는 다음과 같이 구현할 수 있다.

  ``` java
  public class ShippingInfoChangedHandler {
    
    @EventListener(ShippingInfoChangedEvent.class)
    public void handle(ShippingInfoChangedEvent evt) {
      shippingInfoSynchronizer.sync(
      			evt.getOrderNumber(),
        		evt.getNewShippingInfo()
      );
    }
  }
  ```

- 이벤트에 담긴 데이터가 부족하면, 핸들러는 필요한 데이터를 읽기 위해 관련 API를 호출하거나 DB에서 직접 데이터를 읽어와야 한다.

  이벤트는 데이터를 담아야 하지만 그렇다고 이벤트 자체와 관련없는 데이터를 포함할 필요는 없다.

<br/>

### 이벤트의 용도

---

- 이벤트는 크게 두 가지 용도로 쓰인다.

- 첫 번째 용도는 **트리거(Trigger)**이다.

  도메인의 상태가 바뀔 때 다른 후처리가 필요하면 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다. (ex. 주문 취소 시 환불 처리를 위한 트리거로 주문 취소 이벤트 사용)

- 두 번째 용도는 서로 다른 시스템 간의 **데이터 동기화**이다.

<br/>

### 이벤트의 장점

---

- 이벤트를 사용하면 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다.

  ``` java
  public class Order {
    // ...
    
    // 외부 서비스를 실행하기 위해 도메인 서비스를 파라미터로 전달받음
    public void cancel(RefundService refundService) {
      // 주문 취소 로직
      verifyNotYetShipped();
      this.state = OrderState.CANCELED;
      
      // 환불 로직
      this.refundStatus = State.REFUND_STARTED;
      try {
        refundService.refund(getPaymentId());
        this.refundStatus = State.REFUND_COMPLETED;
      } catch (Exception ex) {
        // ...
      }
      
    }
    
    // ...
  }
  ```

  위의 코드를 아래와 같이 바꿀 수 있다.

  ``` java
  public class Order {
    
    public void cancel() {
      verifyNotYetShipped();
      this.state() = OrderState.CANCELED;
      
      Events.raise(new OrderCanceledEvent(number.getNumber()));
    }
  }
  ```

  이벤트를 사용하여 주문 도메인에서 결제 도메인으로의 의존을 제거했다.

- 이벤트 핸들러를 사용하면 기능 확장도 용이하다. (ex. 구매 취소 시 환불과 함께 이메일로 취소 내용을 발송하도록 기능 확장)

<br/>

### 이벤트, 핸들러, 디스패처 구현

---

- 이벤트와 관련된 코드는 다음과 같다.

  - 이벤트 클래스 : 이벤트를 표현한다.
  - 디스패처 : 스프링이 제공하는 **ApplicationEventPublisher**를 이용한다.
  - Events : 이벤트를 발행한다. 마찬가지로 **ApplicationEventPublisher**를 사용한다.
  - 이벤트 핸들러 : 이벤트를 수신해서 처리한다. 스프링이 제공하는 기능을 사용한다.

- 이벤트 자체를 위한 상위 타입은 존재하지 않으므로 원하는 클래스를 이벤트로 사용하면 된다.

  이벤트 이름은 과거 시제를 사용하고, 명시적으로 뒤에 Event를 붙여도 되고 간결함을 위해 생략해도 된다.

  이벤트 클래스는 이벤트 처리를 위해 필요한 필수 데이터를 포함해야 한다.

  ``` java
  public class OrderCanceledEvent {
    private String orderNumber;
    
    public OrderCanceledEvent(String number) {
      this.orderNumber = number;
    }
    
    public String getOrderNumber() { return orderNumber; }
  }
  ```

  모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면 관련 상위 클래스를 만들어 각 이벤트 클래스가 상속받도록 할 수 있다.

  ``` java
  public abstract class Event {
    private long timestamp;
    
    public Event() {
      this.timestamp = System.currentTimeMillis();
    }
    
    public long getTimestamp() { return timestamp; }
  }
  ```

  ``` java
  public class OrderCanceledEvent extends Event {
    private String orderNumber;
    
    public OrderCanceledEvent(String number) {
      super();
      this.orderNumber = number;
    }
    
    public String getOrderNumber() { return orderNumber; }
  }
  ```

- 이벤트 **발생**과 **출판**을 위해서 스프링이 제공하는 **ApplicationEventPublisher**를 사용한다.

  먼저 **Events** 클래스를 알아보자.

  ``` java
  import org.springframework.context.ApplicationEventPublisher;
  
  public class Events {
    private static ApplicationEventPublisher publisher;
    
    static void setPublisher(ApplicationEventPublisher publisher) {
      Events.publisher = publisher;
    }
    
    public static void raise(Object event) {
      if (publisher != null) {
        publisher.publishEvent(event);
      }
    }
  }
  ```

  setPublisher() 메서드에 이벤트 **퍼블리셔를 전달**하기 위해 **스프링 설정 클래스**를 다음과 같이 작성한다.

  ``` java
  @Configuration
  public class EventsConfiguration {
  
    @Autowired
    private ApplicationContext ac;
    
    @Bean
    public InitializingBean eventsInitializer() {
      return () -> Events.setPublisher(ac);
    }
  }
  ```

  eventInitializer() 메서드는 InitializingBean 타입 객체를 빈으로 설정하는데, 이 타입은 스프링 빈 객체를 초기화할 때 사용하는 인터페이스로, 이 기능을 사용해 Events 클래스를 초기화했다.

  참고로 ApplicationContext는 ApplicationEventPublisher를 상속한다.

- **이벤트를 발생**시킬 코드는 Events.raise() 메서드를 사용한다.

  ``` java
  public class Order {
    
    public void cancel() {
      verifyNotYetShipped();
      this.state = OrderState.CANCELED;
      Events.raise(new OrderCanceledEvent(number.getNumber()));
    }
  }
  ```

- 이벤트를 처리할 **핸들러**는 스프링이 제공하는 @EventListener 애너테이션을 사용해 구현한다.

  ``` java
  import org.springframework.context.event.EventListener;
  
  @Service
  public class OrderCanceledEventHandler {
    private RefundService refundService;
    
    public OrderCanceledEventHandler(RefundService refundService) {
      this.refundService = refundService;
    }
    
    @EventListener(OrderCanceledEvent.class)
    public void handle(OrderCanceledEvent event) {
      refundService.refund(event.getOrderNumber());
    }
  }
  ```

- 전체 흐름을 정리해보면 다음과 같다.

  1. 응용 서비스에서 도메인 기능을 실행한다.
  2. 도메인 기능은 Events.raise()를 이용해 이벤트를 발생시킨다.
  3. Events.raise()는 스프링이 제공하는 ApplicationEventPublisher를 이용해 이벤트를 출판한다.
  4. ApplicationEventPublisher는 @EventListener(이벤트타입.class) 애너테이션이 붙은 메서드를 찾아 실행한다.

- 코드 흐름을 보면 응용 서비스와 동일한 트랜잭션 범위에서 이벤트 핸들러를 실행하고 있다.

  즉, 도메인 상태 변경과 이벤트 핸들러는 같은 트랜잭션 범위에서 실행된다.

<br/>

### 동기 이벤트 처리 문제

---

- 이벤트를 사용해 강결합 문제는 해결했지만, 아직 **외부 서비스에 영향을 받는 문제**가 남아있다.

  ``` java
  // 1.응용 서비스 코드
  @Transactional	// 외부 연동 과정에서 익셉션이 발생하면 트랜잭션 처리는?
  public void cancel(OrderNo orderNo) {
    Order order = findOrder(orderNo);
    order.cancel();	// OrderCanceledEvent 발생
  }
  
  // 2.이벤트를 처리하는 코드
  @Service
  public class OrderCanceledEventHandler {
    
    // ...
    
    @EventListener(OrderCanceledEvent.class)
    public void handle(OrderCanceledEvent event) {
      // refundService.refund()가 느려지거나 익셉션이 발생하면?
      refundService.refund(evnet.getOrderNumber());
    }
  }
  ```

  외부 시스템에 의한 성능 저하 문제나, 실패 시 트랜잭션 처리(범위)에 대한 문제가 남아있다.

  이를 해소하기 위한 방법은 **이벤트를 비동기로 처리**하거나 **이벤트를 트랜잭션과 연계**하는 것이다.

<br/>

### 비동기 이벤트 처리

---

- 'A하면 이어서 B하라'는 요구사항 중에서 'A하면 최대 언제까지 B하라'로 바꿀 수 있는 요구사항은 이벤트를 비동기로 처리하는 방식으로 구현할 수 있다.
- 이벤트를 비동기로 구현할 수 있는 방법은 다양한데, 다음 네 가지 방식에 대해 살펴볼 것이다.
  1. 로컬 핸들러를 비동기로 실행하기
  2. 메시지 큐를 사용하기
  3. 이벤트 저장소와 이벤트 포워더 사용하기
  4. 이벤트 저장소와 이벤트 제공 API 사용하기

<br/>

### 비동기 이벤트 처리 - 로컬 핸들러 비동기 실행

---

- 이벤트 핸들러를 **별도 스레드로 실행**하는 방법이다.

- 스프링이 제공하는 @Async 애너테이션을 사용하면 손쉽게 비동기로 이벤트 핸들러를 실행할 수 있다.

  1. @EnableAsync 애너테이션을 사용해서 스프링의 비동기 기능을 활성화

  ``` java
  @SpringBootApplication
  @EnableAsync
  public class ShopApplication {
    
    public static void main(String[] args) {
      SpringApplication.run(ShopApplication.class, args);
    }
  }
  ```

  2. 비동기로 실행할 이벤트 핸들러 메서드에 @Async 애너테이션 붙이기

  ``` java
  @Service
  public class OrderCanceledEventHandler {
    
    @Async
    @EventListener(OrderCanceledEvent.class)
    public void handle(OrderCanceledEvent event) {
      refundService.refund(event.getOrderNumber());
    }
  }
  ```

<br/>

### 비동기 이벤트 처리 - 메시징 시스템 이용

---

- **카프카(Kafka)**나 **래빗MQ(RabbitMQ)**와 같은 메시징 시스템을 이용
- 이벤트 발생시 디스패처는 이벤트를 **메시지 큐**에 보내고, 메시지 큐는 이벤트를 **메시지 리스너**에 전달하고, 메시지 리스너는 알맞은 **이벤트 핸들러**를 이용해 이벤트를 처리하는 방식이다.
- 이벤트를 메시지 큐에 저장하는 과정과, 메시지 큐에서 읽어와 처리하는 과정은 별도 스레드나 프로세스로 처리된다.
- 래빗MQ처럼 많이 사용되는 메시징 시스템은 글로벌 트랜잭션, 클러스터, 고가용성 등을 지원하므로 안정적으로 메시지를 전달할 수 있는 장점이 있고, 다양한 개발 언어와 프로토콜을 지원한다.
- 카프카는 글로벌 트랜잭션을 지원하진 않지만 다른 메시징 시스템에 비해 높은 성능을 보여준다.

<br/>

### 비동기 이벤트 처리 - 이벤트 저장소 이용

---

- 이벤트를 일단 DB에 저장한 뒤 별도의 프로그램을 이용해서 이벤트 핸들러에 전달하는 방식이다.
- 이벤트가 발생하면 **로컬 핸들러**는 **스토리지**에 이벤트를 저장한다. **포워더**는 주기적으로 이벤트 저장소에서 이벤트를 가져와 **이벤트 핸들러**를 실행한다. 포워더는 **별도 스레드를 이용**하기 때문에 이벤트 발행과 처리가 비동기로 처리된다.
- 이벤트 저장소를 이용한 두 번째 방법은 **이벤트를 외부에 제공하는 API**를 사용하는 것이다.
- 포워더 방식이 포워더를 이용해서 이벤트를 외부에 전달한다면, API 방식은 외부 핸들러가 API 서버를 통해 이벤트 목록을 가져간다.
- 포워더 방식은 이벤트 처리 추적 역할까지 포워더가 담당하지만, API 방식은 이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 이벤트를 처리했는지 기억해야 한다.
- 두 방식에서 모두 사용되는 이벤트 저장소의 구조는 다음과 같다.
  - api
    - **EventEntry** : 이벤트 저장소에 보관할 **데이터**이다. 이벤트를 식별하기 위한 id, 이벤트 타입인 type, 직렬화한 데이터 형식인 contentType, 이벤트 데이터 자체인 payload, 이벤트 시간인 timestamp를 갖는다.
    - **EventStore** : 이벤트를 **저장**하고 **조회**하는 **인터페이스를 제공**한다.
  - infra
    - **JdbcEventStore** : JDBC를 이용한 **EventStore 구현 클래스**이다.
  - ui
    - **EventApi** : REST API를 이용해 **이벤트 목록을 제공하는 컨트롤러**이다.

- 이벤트 데이터를 정의하는 **EventEntry 클래스**는 다음과 같다.

  ``` java
  public class EventEntry {
    private long id;
    private String type;
    private String contentType;
    private String payload;
    private long timestamp;
    
    public EventEntry(String type, String contentType, String payload) {
      this.type = type;
      this.contentType = contentType;
      this.payload = payload;
      this.timestamp = System.currentTimeMillis();
    }
    
    public EventEntry(Long id, String type, String contentType, String payload, long timestamp) {
      this.id = id;
      this.type = type;
      this.contentType = contentType;
      this.payload = payload;
      this.timestamp = timestamp;
    }
    
    // Getter
    // ...
  }
  ```

- EventStore는 이벤트 객체를 직렬화하여 payload에 저장한다. 이때 JSON으로 직렬화했다면 contentType 값으로 'application/json'을 갖는다.

  **EventStore 인터페이스**는 다음과 같다.

  ``` java
  public interface EventStore {
    void save(Object event);
    List<EventEntry> get(long offset, long limit);
  }
  ```

- 이벤트는 과거에 벌어진 사건이므로 데이터가 변경되지 않는다. 따라서 EventStore 인터페이스는 새로운 이벤트를 **추가하는 기능**과 **조회하는 기능**만 제공하고, 기존 이벤트 데이터를 수정하는 기능은 제공하지 않는다.

  EventStore 인터페이스를 구현한 **JdbcEventStore 클래스**는 다음과 같다.

  ``` java
  @Component
  public class JdbcEventStore implements EventStore {
    private ObjectMapper objectMapper;
    private JdbcTemplate jdbcTemplate;
    
    // 생성자
    // ...
    
    @Override
    public void save(Object event) {
      EventEntry entry = new EventEntry(event.getClass().getName(),
                                      "application/json", toJson(event));
      jdbcTemplate.update("insert into evententry " + 
                         	"(type, content_type, payload, timestamp) " +
                         	"values (?, ?, ?, ?)",
                   ps -> {
                     ps.setString(1, entry.getType());
                     ps.setString(2, entry.getContentType());
                     ps.setString(3, entry.getPayload());
                     ps.setTimestamp(4, new Timestamp(entry.getTimestamp()));
                   });
    }
    
    private String toJson(Object event) {
      try {
        return objectMapper.writeValueAsString(event);
      } catch (JsonProcessingException e) {
        throw new PayloadConvertException(e);
      }
    }
    
    @Override
    public List<EventEntry> get(long offset, long limit) {
      return jdbcTemplate.query(
        "select * from evententry order by id asc limit ?, ?",
        ps -> {
          ps.setLong(1, offset);
          ps.setLong(2, limit);
        },
        (rs, rowNum) -> {
          return new EventEntry(
            rs.getLong("id"),
            rs.getString("type"),
            rs.getString("content_type"),
            rs.getString("payload"),
            rs.getTimestamp("timestamp").getTime()
          );
        });
    }
  }
  ```

  















































